<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Degradation Analysis</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- JSZip for creating and downloading ZIP files -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>
  <style>
    body {
      font-family: 'Inter', sans-serif;
    }
    input[type="radio"] + label {
      cursor: pointer;
      padding: 8px;
      border-radius: 9999px;
      transition: background-color: 0.2s;
    }
    input[type="radio"]:checked + label {
      background-color: #e5e7eb;
    }
    .dark input[type="radio"]:checked + label {
      background-color: #374151;
    }
    .drop-area {
      border: 2px dashed #d1d5db;
      transition: border-color 0.2s, background-color 0.2s;
    }
    .drop-area.drag-over {
      border-color: #6366f1;
      background-color: #f0f1ff;
    }
    .dark .drop-area.drag-over {
        background-color: #2b3142;
    }
    .button-disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen flex flex-col items-center justify-center p-4 transition-colors">
  
  <button id="darkModeToggle" class="fixed top-4 right-4 p-2 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-colors shadow">
    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="darkModeIcon">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path>
    </svg>
  </button>
  
  <div class="bg-white dark:bg-gray-800 p-8 rounded-lg shadow-lg max-w-4xl w-full transition-colors">
    <div class="flex justify-between items-center mb-4">
        <h1 class="text-3xl font-bold text-center">Image Degradation Analysis</h1>
        <button id="toggleViewBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-200 font-bold py-2 px-4 rounded-full transition-colors text-sm">
            Switch to Batch Mode
        </button>
    </div>

    <!-- ===== SINGLE FILE VIEW ===== -->
    <div id="singleFileView">
      <p class="text-center text-gray-600 dark:text-gray-400 mb-6">
        Use this tool to analyze compression artifacts in a single image or video.
      </p>
      <div id="drop-area-single" class="drop-area p-6 rounded-lg text-center mb-6">
          <label for="fileInput" class="font-semibold mb-2">Drag & Drop or Select a File:</label>
          <input id="fileInput" type="file" accept="image/*,video/*" class="w-full text-sm text-gray-500 dark:text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100 dark:file:bg-violet-800 dark:file:text-violet-200 dark:hover:file:bg-violet-700 cursor-pointer transition-colors mt-2">
      </div>
    </div>

    <!-- ===== BATCH PROCESSING VIEW ===== -->
    <div id="batchView" class="hidden">
        <p class="text-center text-gray-600 dark:text-gray-400 mb-6">
            Process multiple images at once. All images will be resized before processing.
        </p>
        <div id="drop-area-batch" class="drop-area p-6 rounded-lg text-center mb-4">
            <label for="batchFileInput" class="font-semibold mb-2">Drag & Drop or Select Multiple Images:</label>
            <input id="batchFileInput" type="file" accept="image/*" multiple class="w-full text-sm text-gray-500 dark:text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100 dark:file:bg-violet-800 dark:file:text-violet-200 dark:hover:file:bg-violet-700 cursor-pointer transition-colors mt-2">
        </div>
         <div class="flex justify-center mb-4">
            <label for="maxSizeInput" class="font-semibold mr-2 self-center">Max Size (longest side):</label>
            <input type="number" id="maxSizeInput" value="1000" class="bg-gray-200 dark:bg-gray-700 rounded-lg p-2 w-24 text-center">
        </div>
        <div id="fileList" class="text-center text-sm text-gray-500 dark:text-gray-400 mb-4 h-6"></div>
    </div>
    
    <!-- ===== SHARED CONTROLS ===== -->
    <div id="sharedControls" class="border-t border-b border-gray-200 dark:border-gray-700 py-6 my-6">
        <div class="flex flex-col md:flex-row items-center justify-center space-y-4 md:space-y-0 md:space-x-4 mb-6">
          <div class="flex-1 w-full">
            <label for="mInput" class="font-semibold mb-2 block">m (1-5): <span id="mVal" class="font-normal">4</span></label>
            <input id="mInput" type="range" min="1" max="5" value="4" class="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer">
          </div>
          <div class="flex-1 w-full">
            <label for="xInput" class="font-semibold mb-2 block">x (1-10): <span id="xVal" class="font-normal">5</span></label>
            <input id="xInput" type="range" min="1" max="10" value="5" class="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer">
          </div>
        </div>
        
        <div class="flex flex-col items-center justify-center mb-6">
          <div class="flex items-center justify-center mb-4">
            <span id="stitchLabel" class="font-semibold mr-4 text-center">Stitch Direction:</span>
            <div class="flex space-x-2" id="stitchControls">
                <input type="radio" id="stitchNone" name="stitchDirection" value="none" class="hidden" checked>
                <label for="stitchNone" title="None" class="flex items-center justify-center bg-gray-200 dark:bg-gray-700 rounded-full w-8 h-8 hover:bg-gray-300 dark:hover:bg-gray-600"><span class="font-bold text-gray-800 dark:text-gray-200">X</span></label>
                <input type="radio" id="stitchLeft" name="stitchDirection" value="left" class="hidden">
                <label for="stitchLeft" title="Left" class="flex items-center justify-center bg-gray-200 dark:bg-gray-700 rounded-full w-8 h-8 hover:bg-gray-300 dark:hover:bg-gray-600"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-800 dark:text-gray-200" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg></label>
                <input type="radio" id="stitchTop" name="stitchDirection" value="top" class="hidden">
                <label for="stitchTop" title="Top" class="flex items-center justify-center bg-gray-200 dark:bg-gray-700 rounded-full w-8 h-8 hover:bg-gray-300 dark:hover:bg-gray-600"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-800 dark:text-gray-200" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7" /></svg></label>
                <input type="radio" id="stitchBottom" name="stitchDirection" value="bottom" class="hidden">
                <label for="stitchBottom" title="Bottom" class="flex items-center justify-center bg-gray-200 dark:bg-gray-700 rounded-full w-8 h-8 hover:bg-gray-300 dark:hover:bg-gray-600"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-800 dark:text-gray-200" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg></label>
                <input type="radio" id="stitchRight" name="stitchDirection" value="right" class="hidden">
                <label for="stitchRight" title="Right" class="flex items-center justify-center bg-gray-200 dark:bg-gray-700 rounded-full w-8 h-8 hover:bg-gray-300 dark:hover:bg-gray-600"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-800 dark:text-gray-200" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg></label>
            </div>
          </div>
          <div class="flex items-center justify-center">
            <input id="detailsCheck" type="checkbox" class="w-4 h-4 text-violet-600 dark:bg-gray-700 bg-gray-100 rounded border-gray-300 dark:border-gray-600 focus:ring-violet-500">
            <label for="detailsCheck" class="ml-2">Show details on photo?</label>
          </div>
    </div>
    
    <!-- ===== ACTION BUTTONS ===== -->
    <div id="singleFileButtons" class="flex space-x-4 justify-center">
        <button id="processBtn" class="bg-violet-600 hover:bg-violet-700 text-white font-bold py-2 px-6 rounded-full transition-colors">Process</button>
        <button id="gridBtn" class="bg-violet-600 hover:bg-violet-700 text-white font-bold py-2 px-6 rounded-full transition-colors">Grid Analysis</button>
        <button id="standardBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-200 font-bold py-2 px-6 rounded-full transition-colors">STANDARD</button>
        <button id="saveBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-200 font-bold py-2 px-6 rounded-full transition-colors">Save</button>
    </div>

    <div id="batchButtons" class="hidden flex-col items-center justify-center space-y-4">
        <div class="flex space-x-4 justify-center">
            <button id="batchProcessStandardBtn" class="bg-violet-600 hover:bg-violet-700 text-white font-bold py-2 px-6 rounded-full transition-colors">Process All (Standard)</button>
            <button id="batchProcessGridBtn" class="bg-violet-600 hover:bg-violet-700 text-white font-bold py-2 px-6 rounded-full transition-colors">Process All (Grid)</button>
        </div>
        
        <!-- Advanced Settings -->
        <div class="w-full pt-4 mt-4 border-t border-gray-200 dark:border-gray-700">
            <div class="flex items-center justify-center">
                <input id="advancedSettingsCheck" type="checkbox" class="w-4 h-4 text-violet-600 bg-gray-100 rounded border-gray-300 dark:bg-gray-700 dark:border-gray-600 focus:ring-violet-500">
                <label for="advancedSettingsCheck" class="ml-2 font-semibold">Show Advanced Settings</label>
            </div>

            <div id="advancedSettingsContainer" class="hidden mt-4 space-y-4">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 items-center">
                    <div>
                        <label for="reduceSizeSlider" class="font-semibold mb-2 block">Reduce Size: <span id="reduceSizeVal" class="font-normal">50</span>%</label>
                        <input id="reduceSizeSlider" type="range" min="10" max="100" value="50" class="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div>
                        <label class="font-semibold mb-2 block">File Format:</label>
                        <div class="flex space-x-4">
                            <label><input type="radio" name="fileFormat" value="png"> PNG</label>
                            <label><input type="radio" name="fileFormat" value="jpg" checked> JPG</label>
                        </div>
                    </div>
                </div>
                <div id="jpgQualityContainer">
                    <label for="jpgQualitySlider" class="font-semibold mb-2 block">JPG Quality: <span id="jpgQualityVal" class="font-normal">80</span></label>
                    <input id="jpgQualitySlider" type="range" min="1" max="100" value="80" class="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer">
                </div>
                <div>
                     <label class="font-semibold mb-2 block">Download As:</label>
                    <div class="flex space-x-4">
                        <label><input type="radio" name="downloadType" value="individual" checked> Individual Files</label>
                        <label><input type="radio" name="downloadType" value="zip"> ZIP file</label>
                    </div>
                    <p id="zipWarning" class="text-xs text-yellow-600 dark:text-yellow-400 mt-2 hidden">Warning: Zipping large, un-reduced files may be slow or fail in some browsers.</p>
                </div>
            </div>
        </div>

        <button id="batchSaveBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-full transition-colors hidden">Save All</button>
    </div>
    
    <div id="processing-indicator" class="mt-4 text-center text-sm text-gray-600 dark:text-gray-400 min-h-[1.25rem]"></div>

    <div id="canvas-container" class="relative mt-6">
      <canvas id="resultCanvas" class="w-full h-auto rounded-lg shadow-md"></canvas>
    </div>
  </div>

  <script>
    // === DOM Elements ===
    const fileInput = document.getElementById('fileInput');
    const batchFileInput = document.getElementById('batchFileInput');
    const mInput = document.getElementById('mInput');
    const xInput = document.getElementById('xInput');
    const mVal = document.getElementById('mVal');
    const xVal = document.getElementById('xVal');
    const detailsCheck = document.getElementById('detailsCheck');
    const processBtn = document.getElementById('processBtn');
    const gridBtn = document.getElementById('gridBtn');
    const standardBtn = document.getElementById('standardBtn');
    const saveBtn = document.getElementById('saveBtn');
    const darkModeToggle = document.getElementById('darkModeToggle');
    const resultCanvas = document.getElementById('resultCanvas');
    const dropAreaSingle = document.getElementById('drop-area-single');
    const dropAreaBatch = document.getElementById('drop-area-batch');
    const processingIndicator = document.getElementById('processing-indicator');
    const rCtx = resultCanvas.getContext('2d');
    const toggleViewBtn = document.getElementById('toggleViewBtn');
    const singleFileView = document.getElementById('singleFileView');
    const batchView = document.getElementById('batchView');
    const singleFileButtons = document.getElementById('singleFileButtons');
    const batchButtons = document.getElementById('batchButtons');
    const batchProcessStandardBtn = document.getElementById('batchProcessStandardBtn');
    const batchProcessGridBtn = document.getElementById('batchProcessGridBtn');
    const batchSaveBtn = document.getElementById('batchSaveBtn');
    const maxSizeInput = document.getElementById('maxSizeInput');
    const fileList = document.getElementById('fileList');
    const stitchLabel = document.getElementById('stitchLabel');
    // Advanced Settings Elements
    const advancedSettingsCheck = document.getElementById('advancedSettingsCheck');
    const advancedSettingsContainer = document.getElementById('advancedSettingsContainer');
    const reduceSizeSlider = document.getElementById('reduceSizeSlider');
    const reduceSizeVal = document.getElementById('reduceSizeVal');
    const jpgQualityContainer = document.getElementById('jpgQualityContainer');
    const jpgQualitySlider = document.getElementById('jpgQualitySlider');
    const jpgQualityVal = document.getElementById('jpgQualityVal');
    const zipWarning = document.getElementById('zipWarning');


    // === App State ===
    let loadedFile = null;
    let loadedBatchFiles = [];
    let originalFileName = '';
    let processedFrames = [];
    let batchCanvases = [];
    let isVideo = false;
    let isBatchMode = false;

    // === Event Listeners ===
    mInput.addEventListener('input', () => { mVal.textContent = mInput.value; });
    xInput.addEventListener('input', () => { xVal.textContent = xInput.value; });

    // --- UI Mode Toggle ---
    toggleViewBtn.addEventListener('click', () => {
        isBatchMode = !isBatchMode;
        singleFileView.classList.toggle('hidden');
        batchView.classList.toggle('hidden');
        singleFileButtons.classList.toggle('hidden');
        batchButtons.classList.toggle('hidden');
        
        if (isBatchMode) {
            toggleViewBtn.textContent = 'Switch to Single Mode';
            stitchLabel.textContent = 'Stitch Original to Grid:';
            clearCanvas();
        } else {
            toggleViewBtn.textContent = 'Switch to Batch Mode';
            stitchLabel.textContent = 'Stitch Direction:';
            clearCanvas();
        }
    });

    // --- Single File Input ---
    fileInput.addEventListener('change', e => handleSingleFile(e.target.files[0]));
    setupDragDrop(dropAreaSingle, files => handleSingleFile(files[0]));

    async function handleSingleFile(file) {
        if (!file) return;
        loadedFile = file;
        originalFileName = file.name.split('.').slice(0, -1).join('.');
        
        if (file.type.startsWith('image/')) {
            isVideo = false;
            processBtn.textContent = 'Process Image';
            saveBtn.textContent = 'Save';
            await processImageFile(file);
        } else if (file.type.startsWith('video/')) {
            isVideo = true;
            processBtn.textContent = 'Process Video';
            saveBtn.textContent = 'Save Frames';
            setProcessingState(false);
            clearCanvas();
        }
    }

    // --- Batch File Input ---
    batchFileInput.addEventListener('change', e => handleBatchFiles(e.target.files));
    setupDragDrop(dropAreaBatch, files => handleBatchFiles(files));

    function handleBatchFiles(files) {
        if (!files || files.length === 0) return;
        loadedBatchFiles = Array.from(files).filter(f => f.type.startsWith('image/'));
        fileList.textContent = `${loadedBatchFiles.length} image(s) selected.`;
        batchSaveBtn.classList.add('hidden');
        batchCanvases = [];
        clearCanvas();
    }
    
    // --- Processing Buttons ---
    processBtn.addEventListener('click', async () => {
      if (!loadedFile) return;
      if (isVideo) { await processVideoFile(loadedFile); } 
      else { await processImageFile(loadedFile); }
    });
    gridBtn.addEventListener('click', () => generateSingleGrid(loadedFile));
    standardBtn.addEventListener('click', async () => {
        if (!loadedFile || isVideo) return;
        setProcessingState(true);
        mInput.value = 4; xInput.value = 5;
        mVal.textContent = 4; xVal.textContent = 5;
        await processImageFile(loadedFile);
    });
    batchProcessStandardBtn.addEventListener('click', () => processBatch('standard'));
    batchProcessGridBtn.addEventListener('click', () => processBatch('grid'));

    // --- Save Buttons ---
    saveBtn.addEventListener('click', saveSingleResult);
    batchSaveBtn.addEventListener('click', saveBatchResults);

    // --- Dark Mode ---
    darkModeToggle.addEventListener('click', () => {
        document.documentElement.classList.toggle('dark');
        const isDark = document.documentElement.classList.contains('dark');
        const icon = document.getElementById('darkModeIcon');
        icon.innerHTML = isDark 
            ? `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.354 5.354l-.707.707M6.346 6.346l-.707-.707m12.728 0l-.707.707M6.346 17.654l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path>`
            : `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path>`;
    });

    // --- Advanced Settings Listeners ---
    advancedSettingsCheck.addEventListener('change', () => {
        advancedSettingsContainer.classList.toggle('hidden', !advancedSettingsCheck.checked);
    });
    reduceSizeSlider.addEventListener('input', () => { reduceSizeVal.textContent = reduceSizeSlider.value; });
    jpgQualitySlider.addEventListener('input', () => { jpgQualityVal.textContent = jpgQualitySlider.value; });
    document.querySelectorAll('input[name="fileFormat"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
            jpgQualityContainer.classList.toggle('hidden', e.target.value !== 'jpg');
        });
    });
     document.querySelectorAll('input[name="downloadType"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
            zipWarning.classList.toggle('hidden', e.target.value !== 'zip');
        });
    });


    // === Core Logic Functions ===
    
    function setProcessingState(isProcessing, message = 'Processing...') {
      const allButtons = [processBtn, gridBtn, standardBtn, saveBtn, batchProcessGridBtn, batchProcessStandardBtn, batchSaveBtn];
      processingIndicator.textContent = isProcessing ? message : '';
      allButtons.forEach(btn => {
        btn.disabled = isProcessing;
        btn.classList.toggle('button-disabled', isProcessing);
      });
    }
    
    function setupDragDrop(area, callback) {
        area.addEventListener('dragover', e => { e.preventDefault(); area.classList.add('drag-over'); });
        area.addEventListener('dragleave', e => { area.classList.remove('drag-over'); });
        area.addEventListener('drop', e => {
            e.preventDefault();
            area.classList.remove('drag-over');
            if (e.dataTransfer.files.length > 0) { callback(e.dataTransfer.files); }
        });
    }

    function clearCanvas() {
        rCtx.clearRect(0, 0, resultCanvas.width, resultCanvas.height);
        resultCanvas.width = 1; resultCanvas.height = 1;
    }

    function drawResult(canvasElem) {
        if (canvasElem) {
            resultCanvas.width = canvasElem.width;
            resultCanvas.height = canvasElem.height;
            rCtx.clearRect(0, 0, resultCanvas.width, resultCanvas.height);
            rCtx.drawImage(canvasElem, 0, 0);
        }
    }

    function addDetailsText(ctx, text, x, y, width, height) {
        const padding = Math.min(width, height) * 0.02;
        const fontSize = Math.max(12, Math.min(width, height) * 0.03);
        ctx.font = `bold ${fontSize}px 'Courier New', Courier, monospace`;
        ctx.fillStyle = 'white';
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'black';
        const textX = x + padding;
        const textY = y + height - padding;
        ctx.strokeText(text, textX, textY);
        ctx.fillText(text, textX, textY);
    }
    
    async function processImageFile(file) {
      setProcessingState(true);
      const img = await loadImage(URL.createObjectURL(file));
      const mValNum = clampInt(parseInt(mInput.value), 1, 5);
      const xValNum = clampInt(parseInt(xInput.value), 1, 10);
      const stitchDirection = document.querySelector('input[name="stitchDirection"]:checked').value;
      const showDetails = detailsCheck.checked;
      
      const finalCanvas = await processSingleImage(img, mValNum, xValNum, stitchDirection);
      
      if (showDetails && stitchDirection === 'none') {
        const ctx = finalCanvas.getContext('2d');
        addDetailsText(ctx, `m=${mValNum}, x=${xValNum}`, 0, 0, finalCanvas.width, finalCanvas.height);
      }
      
      drawResult(finalCanvas);
      setProcessingState(false);
    }
    
    async function generateSingleGrid(file) {
        if (!file || isVideo) return;
        setProcessingState(true, 'Creating Grid...');
        
        const img = await loadImage(URL.createObjectURL(file));
        const mValNum = clampInt(parseInt(mInput.value), 1, 5);
        const showDetails = detailsCheck.checked;
        const stitchDirection = document.querySelector('input[name="stitchDirection"]:checked').value;

        const gridCanvas = await createGridCanvas(img, mValNum, showDetails);
        const finalCanvas = stitchGridWithOriginal(img, gridCanvas, stitchDirection);
        
        drawResult(finalCanvas);
        setProcessingState(false);
    }
    
    async function processBatch(mode) {
        if (loadedBatchFiles.length === 0) return;
        setProcessingState(true, 'Starting batch process...');
        batchCanvases = [];
        batchSaveBtn.classList.add('hidden');
        const maxSize = parseInt(maxSizeInput.value) || 1000;
        
        for (let i = 0; i < loadedBatchFiles.length; i++) {
            const file = loadedBatchFiles[i];
            setProcessingState(true, `Processing ${i + 1} of ${loadedBatchFiles.length}: ${file.name}`);
            
            const originalImage = await loadImage(URL.createObjectURL(file));
            const resizedImage = await resizeImage(originalImage, maxSize);
            
            let resultCanvas;
            if (mode === 'standard') {
                const mValNum = clampInt(parseInt(mInput.value), 1, 5);
                const xValNum = clampInt(parseInt(xInput.value), 1, 10);
                const stitchDirection = document.querySelector('input[name="stitchDirection"]:checked').value;
                const showDetails = detailsCheck.checked;
                
                resultCanvas = await processSingleImage(resizedImage, mValNum, xValNum, stitchDirection);
                if (showDetails && stitchDirection === 'none') {
                   const ctx = resultCanvas.getContext('2d');
                   addDetailsText(ctx, `m=${mValNum}, x=${xValNum}`, 0, 0, resultCanvas.width, resultCanvas.height);
                }

            } else { // mode === 'grid'
                const mValNum = clampInt(parseInt(mInput.value), 1, 5);
                const showDetails = detailsCheck.checked;
                const stitchDirection = document.querySelector('input[name="stitchDirection"]:checked').value;

                const gridCanvas = await createGridCanvas(resizedImage, mValNum, showDetails);
                resultCanvas = stitchGridWithOriginal(resizedImage, gridCanvas, stitchDirection);
            }
            
            const originalFileName = file.name.split('.').slice(0, -1).join('.');
            const newFileName = `${originalFileName}_${mode}`; // Extension added at save time
            
            batchCanvases.push({ name: newFileName, canvas: resultCanvas });
            drawResult(resultCanvas); 
        }

        setProcessingState(false, 'Batch processing complete.');
        processingIndicator.textContent = `${batchCanvases.length} images processed and are ready to save.`;
        if (batchCanvases.length > 0) {
            batchSaveBtn.classList.remove('hidden');
        }
    }
    
    function loadImage(src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = src;
        });
    }

    function resizeImage(img, maxSize) {
        const { width, height } = img;
        let newWidth, newHeight;
        if (width > height) {
            newWidth = maxSize;
            newHeight = (height / width) * maxSize;
        } else {
            newHeight = maxSize;
            newWidth = (width / height) * maxSize;
        }
        const canvas = document.createElement('canvas');
        canvas.width = newWidth;
        canvas.height = newHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, newWidth, newHeight);
        return canvas;
    }

    async function processSingleImage(img, m, x, stitchDirection) {
        const scaleFactor = m * (x * 5) * 47;
        const quality = Math.min(10, x);
        const compImg = await compressImage(img, quality);
        const diffCanvas = createDiff(img, compImg, scaleFactor);
        return stitchImage(img, diffCanvas, stitchDirection);
    }
    
    async function createGridCanvas(img, mValNum, showDetails) {
        const resultCanvases = [];
        for (let x = 1; x <= 10; x++) {
            const processedCanvas = await processSingleImage(img, mValNum, x, 'none');
            if (showDetails) {
                const ctx = processedCanvas.getContext('2d');
                addDetailsText(ctx, `m=${mValNum}, x=${x}`, 0, 0, processedCanvas.width, processedCanvas.height);
            }
            resultCanvases.push(processedCanvas);
        }

        const gridCanvas = document.createElement('canvas');
        const gridCtx = gridCanvas.getContext('2d');
        const itemWidth = img.width; const itemHeight = img.height;
        gridCanvas.width = itemWidth * 5; gridCanvas.height = itemHeight * 2;
        resultCanvases.forEach((canvasData, i) => {
            const row = Math.floor(i / 5); const col = i % 5;
            gridCtx.drawImage(canvasData, col * itemWidth, row * itemHeight);
        });
        return gridCanvas;
    }

    function compressImage(imgElem, q) {
      return new Promise(resolve => {
        let tempCanvas = document.createElement('canvas');
        tempCanvas.width = imgElem.width; tempCanvas.height = imgElem.height;
        let tCtx = tempCanvas.getContext('2d');
        tCtx.drawImage(imgElem, 0, 0);
        let data = tempCanvas.toDataURL('image/jpeg', q / 100);
        resolve(loadImage(data));
      });
    }

    function createDiff(orig, comp, sFactor) {
      let w = orig.width, h = orig.height;
      let oCtx = document.createElement('canvas').getContext('2d'); oCtx.canvas.width=w; oCtx.canvas.height=h; oCtx.drawImage(orig, 0, 0);
      let oData = oCtx.getImageData(0, 0, w, h).data;
      let cCtx = document.createElement('canvas').getContext('2d'); cCtx.canvas.width=w; cCtx.canvas.height=h; cCtx.drawImage(comp, 0, 0);
      let cData = cCtx.getImageData(0, 0, w, h).data;
      let dCtx = document.createElement('canvas').getContext('2d'); dCtx.canvas.width=w; dCtx.canvas.height=h;
      let diffData = dCtx.createImageData(w, h); let diffArr = diffData.data;
      let maxDiff = 0;
      for (let i = 0; i < oData.length; i += 4) {
        maxDiff = Math.max(maxDiff, Math.abs(oData[i] - cData[i]), Math.abs(oData[i + 1] - cData[i + 1]), Math.abs(oData[i + 2] - cData[i + 2]));
      }
      let scale = sFactor / (maxDiff || 1);
      for (let i = 0; i < oData.length; i += 4) {
        diffArr[i]     = clamp(Math.abs(oData[i] - cData[i]) * scale, 0, 255);
        diffArr[i + 1] = clamp(Math.abs(oData[i + 1] - cData[i + 1]) * scale, 0, 255);
        diffArr[i + 2] = clamp(Math.abs(oData[i + 2] - cData[i + 2]) * scale, 0, 255);
        diffArr[i + 3] = 255;
      }
      dCtx.putImageData(diffData, 0, 0);
      return dCtx.canvas;
    }

    function resizeToMatch(imageToResize, referenceImage, dimension) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const { width: origW, height: origH } = imageToResize;
        const { width: refW, height: refH } = referenceImage;
        const aspectRatio = origW / origH;
        let newW, newH;
        if (dimension === 'height') { newH = refH; newW = newH * aspectRatio; } 
        else { newW = refW; newH = newW / aspectRatio; }
        canvas.width = newW; canvas.height = newH;
        ctx.drawImage(imageToResize, 0, 0, newW, newH);
        return canvas;
    }

    function stitchGridWithOriginal(originalImage, gridCanvas, direction) {
        if (direction === 'none') { return gridCanvas; }
        let resizedOriginal;
        let finalCanvas = document.createElement('canvas');
        let fCtx = finalCanvas.getContext('2d');
        const { width: gridW, height: gridH } = gridCanvas;
        if (direction === 'left' || direction === 'right') {
            resizedOriginal = resizeToMatch(originalImage, gridCanvas, 'height');
            const { width: resizedW, height: resizedH } = resizedOriginal;
            finalCanvas.width = gridW + resizedW; finalCanvas.height = gridH;
            if (direction === 'left') { fCtx.drawImage(resizedOriginal, 0, 0); fCtx.drawImage(gridCanvas, resizedW, 0); } 
            else { fCtx.drawImage(gridCanvas, 0, 0); fCtx.drawImage(resizedOriginal, gridW, 0); }
        } else { // 'top' or 'bottom'
            resizedOriginal = resizeToMatch(originalImage, gridCanvas, 'width');
            const { width: resizedW, height: resizedH } = resizedOriginal;
            finalCanvas.width = gridW; finalCanvas.height = gridH + resizedH;
            if (direction === 'top') { fCtx.drawImage(resizedOriginal, 0, 0); fCtx.drawImage(gridCanvas, 0, resizedH); } 
            else { fCtx.drawImage(gridCanvas, 0, 0); fCtx.drawImage(resizedOriginal, 0, gridH); }
        }
        return finalCanvas;
    }

    function stitchImage(orig, diff, direction) {
        let finalCanvas = document.createElement('canvas'); let fCtx = finalCanvas.getContext('2d');
        let w = orig.width, h = orig.height;
        switch(direction) {
            case 'left': finalCanvas.width = w * 2; finalCanvas.height = h; fCtx.drawImage(diff, 0, 0); fCtx.drawImage(orig, w, 0); break;
            case 'right': finalCanvas.width = w * 2; finalCanvas.height = h; fCtx.drawImage(orig, 0, 0); fCtx.drawImage(diff, w, 0); break;
            case 'top': finalCanvas.width = w; finalCanvas.height = h * 2; fCtx.drawImage(diff, 0, 0); fCtx.drawImage(orig, 0, h); break;
            case 'bottom': finalCanvas.width = w; finalCanvas.height = h * 2; fCtx.drawImage(orig, 0, 0); fCtx.drawImage(diff, 0, h); break;
            default: finalCanvas = diff; break;
        }
        return finalCanvas;
    }

    // --- Saving Functions ---
    async function saveSingleResult() {
        if (!loadedFile) return;
        if (isVideo) {
            const zip = new JSZip();
            processedFrames.forEach((frame, index) => {
                const base64 = frame.split(',')[1];
                zip.file(`${originalFileName}_frame_${String(index+1).padStart(4, '0')}.png`, base64, { base64: true });
            });
            const content = await zip.generateAsync({ type: "blob", compression: "STORE" });
            downloadBlob(content, `${originalFileName}_processed_frames.zip`);
        } else {
            const dataURL = resultCanvas.toDataURL('image/png');
            downloadDataURL(dataURL, `${originalFileName}_IDA.png`);
        }
    }
    
    async function saveBatchResults() {
        if (!batchCanvases || batchCanvases.length === 0) return;
        setProcessingState(true, 'Preparing downloads...');

        const useAdvanced = advancedSettingsCheck.checked;
        const sizeReduction = useAdvanced ? parseInt(reduceSizeSlider.value) / 100 : 1.0;
        const format = useAdvanced ? document.querySelector('input[name="fileFormat"]:checked').value : 'png';
        const quality = useAdvanced ? parseInt(jpgQualitySlider.value) / 100 : 0.8;
        const downloadType = useAdvanced ? document.querySelector('input[name="downloadType"]:checked').value : 'individual';
        const mimeType = `image/${format === 'jpg' ? 'jpeg' : 'png'}`;

        const getOutputFile = (item) => {
            return new Promise(resolve => {
                const sourceCanvas = item.canvas;
                const tempCanvas = document.createElement('canvas');
                const tCtx = tempCanvas.getContext('2d');
                
                tempCanvas.width = sourceCanvas.width * sizeReduction;
                tempCanvas.height = sourceCanvas.height * sizeReduction;
                
                tCtx.drawImage(sourceCanvas, 0, 0, tempCanvas.width, tempCanvas.height);
                
                if (downloadType === 'zip') {
                    tempCanvas.toBlob(resolve, mimeType, quality);
                } else {
                    resolve(tempCanvas.toDataURL(mimeType, quality));
                }
            });
        };

        if (downloadType === 'zip') {
            const zip = new JSZip();
            for (let i = 0; i < batchCanvases.length; i++) {
                const item = batchCanvases[i];
                setProcessingState(true, `Zipping ${i + 1} of ${batchCanvases.length}: ${item.name}`);
                const blob = await getOutputFile(item);
                zip.file(`${item.name}.${format}`, blob);
            }
            setProcessingState(true, 'Generating ZIP file...');
            const content = await zip.generateAsync({ type: "blob", compression: "STORE" });
            downloadBlob(content, 'IDA_Batch_Results.zip');

        } else { // Individual downloads
             for (let i = 0; i < batchCanvases.length; i++) {
                const item = batchCanvases[i];
                setProcessingState(true, `Downloading ${i + 1} of ${batchCanvases.length}: ${item.name}`);
                const dataURL = await getOutputFile(item);
                downloadDataURL(dataURL, `${item.name}.${format}`);
                await new Promise(resolve => setTimeout(resolve, 250)); 
            }
        }
        
        setProcessingState(false);
        processingIndicator.textContent = `Finished downloading ${batchCanvases.length} files.`;
        batchCanvases = [];
    }

    function downloadDataURL(dataURL, filename) {
        const link = document.createElement('a'); link.href = dataURL; link.download = filename;
        document.body.appendChild(link); link.click(); document.body.removeChild(link);
    }
    
    function downloadBlob(blob, filename) {
        const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = filename;
        document.body.appendChild(link); link.click(); document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
    }
    
    // --- Utility Functions ---
    function clamp(val, mn, mx) { return Math.max(mn, Math.min(mx, val)); }
    function clampInt(val, mn, mx) { return Math.floor(clamp(Math.abs(val), mn, mx)); }
    
    async function processVideoFile(file) {
        alert("Video processing is not supported in this version.");
        setProcessingState(false);
    }
  </script>
</body>
</html>

