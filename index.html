<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Degradation Analysis</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- JSZip for creating and downloading ZIP files -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>
  <style>
    body {
      font-family: 'Inter', sans-serif;
    }
    input[type="radio"] + label {
      cursor: pointer;
      padding: 8px;
      border-radius: 9999px;
      transition: background-color 0.2s;
    }
    input[type="radio"]:checked + label {
      background-color: #e5e7eb;
    }
    .dark input[type="radio"]:checked + label {
      background-color: #374151;
    }
    #drop-area {
      border: 2px dashed transparent;
      transition: border-color 0.2s;
    }
    #drop-area.drag-over {
      border-color: #6366f1;
    }
    .button-disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen flex flex-col items-center justify-center p-4 transition-colors">
  
  <button id="darkModeToggle" class="fixed top-4 right-4 p-2 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-colors shadow">
    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="darkModeIcon">
      <!-- Icon will be updated by JS -->
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path>
    </svg>
  </button>
  
  <div id="drop-area" class="bg-white dark:bg-gray-800 p-8 rounded-lg shadow-lg max-w-2xl w-full transition-colors">
    <h1 class="text-3xl font-bold mb-2 text-center">Image Degradation Analysis</h1>
    <p class="text-center text-gray-600 dark:text-gray-400 mb-6">
      Use this tool to analyze compression artifacts in an image or video. Drag and drop a file or use the button below.
    </p>

    <div class="flex flex-col md:flex-row items-center justify-center space-y-4 md:space-y-0 md:space-x-4 mb-6">
      <div class="flex flex-col w-full">
        <label for="fileInput" class="font-semibold mb-2">Select File:</label>
        <input id="fileInput" type="file" accept="image/*,video/*" class="w-full text-sm text-gray-500 dark:text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100 dark:file:bg-violet-800 dark:file:text-violet-200 dark:hover:file:bg-violet-700 cursor-pointer transition-colors">
      </div>
    </div>

    <div class="flex flex-col md:flex-row items-center justify-center space-y-4 md:space-y-0 md:space-x-4 mb-6">
      <div class="flex-1 w-full">
        <label for="mInput" class="font-semibold mb-2 block">m (1-5): <span id="mVal" class="font-normal">4</span></label>
        <input id="mInput" type="range" min="1" max="5" value="4" class="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer">
      </div>
      <div class="flex-1 w-full">
        <label for="xInput" class="font-semibold mb-2 block">x (1-10): <span id="xVal" class="font-normal">5</span></label>
        <input id="xInput" type="range" min="1" max="10" value="5" class="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer">
      </div>
    </div>
    
    <div class="flex flex-col items-center justify-center mb-6">
      <div class="flex items-center justify-center mb-4">
        <span class="font-semibold mr-4">Stitch Direction:</span>
        <div class="flex space-x-2">
            <input type="radio" id="stitchNone" name="stitchDirection" value="none" class="hidden" checked>
            <label for="stitchNone" class="flex items-center justify-center bg-gray-200 dark:bg-gray-700 rounded-full w-8 h-8 hover:bg-gray-300 dark:hover:bg-gray-600">
                <span class="font-bold text-gray-800 dark:text-gray-200">X</span>
            </label>
            <input type="radio" id="stitchLeft" name="stitchDirection" value="left" class="hidden">
            <label for="stitchLeft" class="flex items-center justify-center bg-gray-200 dark:bg-gray-700 rounded-full w-8 h-8 hover:bg-gray-300 dark:hover:bg-gray-600">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-800 dark:text-gray-200" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                </svg>
            </label>
            <input type="radio" id="stitchTop" name="stitchDirection" value="top" class="hidden">
            <label for="stitchTop" class="flex items-center justify-center bg-gray-200 dark:bg-gray-700 rounded-full w-8 h-8 hover:bg-gray-300 dark:hover:bg-gray-600">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-800 dark:text-gray-200" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7" />
                </svg>
            </label>
            <input type="radio" id="stitchBottom" name="stitchDirection" value="bottom" class="hidden">
            <label for="stitchBottom" class="flex items-center justify-center bg-gray-200 dark:bg-gray-700 rounded-full w-8 h-8 hover:bg-gray-300 dark:hover:bg-gray-600">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-800 dark:text-gray-200" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
            </label>
            <input type="radio" id="stitchRight" name="stitchDirection" value="right" class="hidden">
            <label for="stitchRight" class="flex items-center justify-center bg-gray-200 dark:bg-gray-700 rounded-full w-8 h-8 hover:bg-gray-300 dark:hover:bg-gray-600">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-800 dark:text-gray-200" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                </svg>
            </label>
        </div>
      </div>
      <div class="flex items-center justify-center">
        <input id="detailsCheck" type="checkbox" class="w-4 h-4 text-violet-600 dark:bg-gray-700 bg-gray-100 rounded border-gray-300 dark:border-gray-600 focus:ring-violet-500">
        <label for="detailsCheck" class="ml-2">Show details on photo?</label>
      </div>
    </div>

    <div class="flex space-x-4 justify-center">
      <button id="processBtn" class="bg-violet-600 hover:bg-violet-700 text-white font-bold py-2 px-6 rounded-full transition-colors">
        Process
      </button>
      <button id="gridBtn" class="bg-violet-600 hover:bg-violet-700 text-white font-bold py-2 px-6 rounded-full transition-colors">
        Grid Analysis
      </button>
      <button id="standardBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-200 font-bold py-2 px-6 rounded-full transition-colors">
        STANDARD
      </button>
      <button id="saveBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-200 font-bold py-2 px-6 rounded-full transition-colors">
        Save
      </button>
    </div>
    
    <!-- This div is always present to prevent layout shift -->
    <div id="processing-indicator" class="mt-4 hidden text-center text-sm text-gray-600 dark:text-gray-400 min-h-[1.25rem]">
        Processing...
    </div>

    <div id="canvas-container" class="relative mt-6">
      <canvas id="resultCanvas" class="w-full h-auto rounded-lg shadow-md"></canvas>
    </div>
  </div>

  <script>
    let fileInput = document.getElementById('fileInput');
    let mInput = document.getElementById('mInput');
    let xInput = document.getElementById('xInput');
    let mVal = document.getElementById('mVal');
    let xVal = document.getElementById('xVal');
    let detailsCheck = document.getElementById('detailsCheck');
    let processBtn = document.getElementById('processBtn');
    let gridBtn = document.getElementById('gridBtn');
    let standardBtn = document.getElementById('standardBtn');
    let saveBtn = document.getElementById('saveBtn');
    let darkModeToggle = document.getElementById('darkModeToggle');
    let resultCanvas = document.getElementById('resultCanvas');
    let dropArea = document.getElementById('drop-area');
    let processingIndicator = document.getElementById('processing-indicator');
    let rCtx = resultCanvas.getContext('2d');
    let loadedFile = null;
    let originalFileName = '';
    let processedFrames = [];
    let isVideo = false;

    mInput.addEventListener('input', () => { mVal.textContent = mInput.value; });
    xInput.addEventListener('input', () => { xVal.textContent = xInput.value; });

    // Handles the UI state for processing
    function setProcessingState(isProcessing, message = 'Processing...') {
      const buttons = [processBtn, gridBtn, standardBtn, saveBtn];
      if (isProcessing) {
        processingIndicator.textContent = message;
        processingIndicator.classList.remove('hidden');
        buttons.forEach(btn => {
          btn.disabled = true;
          btn.classList.add('opacity-50', 'cursor-not-allowed');
        });
      } else {
        processingIndicator.classList.add('hidden');
        buttons.forEach(btn => {
          btn.disabled = false;
          btn.classList.remove('opacity-50', 'cursor-not-allowed');
        });
      }
    }

    // Handles initial file selection
    fileInput.addEventListener('change', async e => {
      const files = e.target.files;
      if (!files.length) return;
      
      loadedFile = files[0];
      originalFileName = loadedFile.name.split('.').slice(0, -1).join('.');
      
      if (loadedFile.type.startsWith('image/')) {
        isVideo = false;
        processBtn.textContent = 'Process Image';
        saveBtn.textContent = 'Save';
        await processImageFile(loadedFile); // Auto-process image
      } else if (loadedFile.type.startsWith('video/')) {
        isVideo = true;
        processBtn.textContent = 'Process Video';
        saveBtn.textContent = 'Save Frames';
        // Do not auto-process, just reset UI and wait for user click
        setProcessingState(false);
      } else {
        setProcessingState(false);
      }
    });
    
    // Drag and drop events
    dropArea.addEventListener('dragover', e => {
      e.preventDefault();
      dropArea.classList.add('drag-over');
    });

    dropArea.addEventListener('dragleave', e => {
      dropArea.classList.remove('drag-over');
    });

    dropArea.addEventListener('drop', async e => {
      e.preventDefault();
      dropArea.classList.remove('drag-over');
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        loadedFile = files[0];
        originalFileName = loadedFile.name.split('.').slice(0, -1).join('.');
        if (loadedFile.type.startsWith('image/')) {
          isVideo = false;
          processBtn.textContent = 'Process Image';
          saveBtn.textContent = 'Save';
          await processImageFile(loadedFile);
        } else if (loadedFile.type.startsWith('video/')) {
          isVideo = true;
          processBtn.textContent = 'Process Video';
          saveBtn.textContent = 'Save Frames';
          setProcessingState(false);
        } else {
          setProcessingState(false);
        }
      }
    });

    // Central button click handler
    processBtn.addEventListener('click', async () => {
        if (!loadedFile) return;
        
        if (isVideo) {
          await processVideoFile(loadedFile);
        } else {
          await processImageFile(loadedFile);
        }
    });

    gridBtn.addEventListener('click', async () => {
        if (!loadedFile || isVideo) return;
        setProcessingState(true, 'Creating Grid...');
        
        let mValNum = clampInt(parseInt(mInput.value), 1, 5);
        let showDetails = detailsCheck.checked;
        const resultCanvases = [];
        const img = new Image();
        img.src = URL.createObjectURL(loadedFile);
        
        img.onload = async () => {
            for (let x = 1; x <= 10; x++) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = img.width;
                tempCanvas.height = img.height;
                tempCtx.drawImage(img, 0, 0);

                const processedCanvas = await new Promise(resolve => {
                    processFile(tempCanvas, mValNum, x, 'none', showDetails, resolve);
                });
                resultCanvases.push({ canvas: processedCanvas, xValue: x });
            }

            const gridCanvas = document.createElement('canvas');
            const gridCtx = gridCanvas.getContext('2d');
            const itemWidth = img.width;
            const itemHeight = img.height;
            gridCanvas.width = itemWidth * 5;
            gridCanvas.height = itemHeight * 2;
            
            for (let i = 0; i < resultCanvases.length; i++) {
                const row = Math.floor(i / 5);
                const col = i % 5;
                const canvasData = resultCanvases[i].canvas;
                const xVal = resultCanvases[i].xValue;

                gridCtx.drawImage(canvasData, col * itemWidth, row * itemHeight);
                
                if (showDetails) {
                    const text = `m=${mValNum}, x=${xVal}`;
                    const padding = 10;
                    gridCtx.font = `8px 'Courier New', Courier, monospace`;
                    gridCtx.fillStyle = 'white';
                    gridCtx.lineWidth = 2;
                    gridCtx.strokeStyle = 'black';
                    const textX = col * itemWidth + padding;
                    const textY = row * itemHeight + itemHeight - padding;
                    gridCtx.strokeText(text, textX, textY);
                    gridCtx.fillText(text, textX, textY);
                }
            }
            drawResult(gridCanvas);
            setProcessingState(false);
        };
    });

    standardBtn.addEventListener('click', async () => {
      if (!loadedFile || isVideo) return;
      setProcessingState(true);
      mInput.value = 4;
      xInput.value = 5;
      mVal.textContent = 4;
      xVal.textContent = 5;
      await processImageFile(loadedFile);
    });

    saveBtn.addEventListener('click', async () => {
      if (!loadedFile) return;

      if (isVideo) {
        const zip = new JSZip();
        processedFrames.forEach((frame, index) => {
          const dataURL = frame;
          const base64 = dataURL.split(',')[1];
          zip.file(`${originalFileName}_frame_${String(index+1).padStart(4, '0')}.png`, base64, { base64: true });
        });

        zip.generateAsync({ type: "blob" }).then(content => {
          const link = document.createElement('a');
          link.href = URL.createObjectURL(content);
          link.download = `${originalFileName}_processed_frames.zip`;
          link.click();
        });

      } else {
        const dataURL = resultCanvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.href = dataURL;
        link.download = `${originalFileName}_IDA.png`;
        link.click();
      }
    });

    darkModeToggle.addEventListener('click', () => {
      document.documentElement.classList.toggle('dark');
      const isDark = document.documentElement.classList.contains('dark');
      const icon = document.getElementById('darkModeIcon');
      if (isDark) {
        icon.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.354 5.354l-.707.707M6.346 6.346l-.707-.707m12.728 0l-.707.707M6.346 17.654l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path>`;
      } else {
        icon.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path>`;
      }
    });

    async function processImageFile(file) {
      setProcessingState(true);
      return new Promise(resolve => {
        const img = new Image();
        img.onload = () => {
          resultCanvas.width = img.width;
          resultCanvas.height = img.height;
          rCtx.clearRect(0, 0, resultCanvas.width, resultCanvas.height);
          rCtx.drawImage(img, 0, 0);

          const mValNum = clampInt(parseInt(mInput.value), 1, 5);
          const xValNum = clampInt(parseInt(xInput.value), 1, 10);
          const stitchDirection = document.querySelector('input[name="stitchDirection"]:checked').value;
          const showDetails = detailsCheck.checked;
          
          processFile(img, mValNum, xValNum, stitchDirection, showDetails, finalCanvas => {
            drawResult(finalCanvas, mValNum, xValNum, showDetails, 0, 0);
            setProcessingState(false);
            resolve();
          });
        };
        img.src = URL.createObjectURL(file);
      });
    }

    async function processVideoFile(file) {
      setProcessingState(true, 'Preparing video...');
      processedFrames = [];

      const video = document.createElement('video');
      video.src = URL.createObjectURL(file);
      video.muted = true;
      video.preload = 'metadata';
      video.crossOrigin = 'anonymous';

      // Wait for the video metadata to load
      await new Promise(resolve => {
        video.onloadedmetadata = () => resolve();
      });

      const frameCanvas = document.createElement('canvas');
      const frameCtx = frameCanvas.getContext('2d');
      frameCanvas.width = video.videoWidth;
      frameCanvas.height = video.videoHeight;
      resultCanvas.width = video.videoWidth;
      resultCanvas.height = video.videoHeight;
      
      const step = 1 / 30; // Step through at 30 frames per second
      let time = 0;
      const totalFrames = Math.floor(video.duration / step);

      while (time < video.duration) {
        setProcessingState(true, `Processing frame ${processedFrames.length + 1} of approximately ${totalFrames}...`);
        
        video.currentTime = time;
        await new Promise(resolve => {
          video.onseeked = () => resolve();
        });

        frameCtx.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);
        
        const mValNum = clampInt(parseInt(mInput.value), 1, 5);
        const xValNum = clampInt(parseInt(xInput.value), 1, 10);
        const stitchDirection = document.querySelector('input[name="stitchDirection"]:checked').value;
        const showDetails = detailsCheck.checked;
        
        await new Promise(resolve => {
            processFile(frameCanvas, mValNum, xValNum, stitchDirection, showDetails, processedFrameCanvas => {
                processedFrames.push(processedFrameCanvas.toDataURL('image/png'));
                drawResult(processedFrameCanvas);
                resolve();
            });
        });
        
        time += step;
      }
      
      setProcessingState(false);
    }

    // This function can now take a callback to handle asynchronous processing
    function processFile(imgElem, m, x, stitchDirection, showDetails, callback) {
      let scaleFactor = m * (x * 5) * 47;
      let quality = Math.min(10, x);

      compressImage(imgElem, quality, compImg => {
        let diffCanvas = createDiff(imgElem, compImg, scaleFactor);
        let finalCanvas;
        let originalWidth = imgElem.width;
        let originalHeight = imgElem.height;
        let originalImageX = 0;
        let originalImageY = 0;

        if (stitchDirection === 'none') {
            finalCanvas = diffCanvas;
            originalImageX = 0;
            originalImageY = 0;
        } else {
            finalCanvas = stitchImage(imgElem, diffCanvas, stitchDirection);
            switch(stitchDirection) {
                case 'left':
                    originalImageX = originalWidth;
                    break;
                case 'right':
                    originalImageX = 0;
                    break;
                case 'top':
                    originalImageY = originalHeight;
                    break;
                case 'bottom':
                    originalImageY = 0;
                    break;
            }
        }

        if (callback) {
            callback(finalCanvas);
        } else {
            drawResult(finalCanvas, m, x, showDetails, originalImageX, originalImageY);
            setProcessingState(false);
        }
      });
    }

    function compressImage(imgElem, q, callback) {
      let w = imgElem.width, h = imgElem.height;
      let tempCanvas = document.createElement('canvas');
      tempCanvas.width = w; 
      tempCanvas.height = h;
      let tCtx = tempCanvas.getContext('2d');
      tCtx.drawImage(imgElem, 0, 0);
      let data = tempCanvas.toDataURL('image/jpeg', q * 0.01);
      let cImg = new Image();
      cImg.onload = () => callback(cImg);
      cImg.src = data;
    }

    function createDiff(orig, comp, sFactor) {
      let w = orig.width, h = orig.height;
      let oCanvas = document.createElement('canvas');
      oCanvas.width = w; 
      oCanvas.height = h;
      let oCtx = oCanvas.getContext('2d');
      oCtx.drawImage(orig, 0, 0);
      let oData = oCtx.getImageData(0, 0, w, h);
      let cCanvas = document.createElement('canvas');
      cCanvas.width = w; 
      cCanvas.height = h;
      let cCtx = cCanvas.getContext('2d');
      cCtx.drawImage(comp, 0, 0);
      let cData = cCtx.getImageData(0, 0, w, h);
      let dCanvas = document.createElement('canvas');
      dCanvas.width = w; 
      dCanvas.height = h;
      let dCtx = dCanvas.getContext('2d');
      let diffData = dCtx.createImageData(w, h);
      let oArr = oData.data;
      let cArr = cData.data;
      let dArr = diffData.data;
      let maxDiff = 0;
      for (let i = 0; i < oArr.length; i += 4) {
        let r = Math.abs(oArr[i] - cArr[i]);
        let g = Math.abs(oArr[i + 1] - cArr[i + 1]);
        let b = Math.abs(oArr[i + 2] - cArr[i + 2]);
        maxDiff = Math.max(maxDiff, r, g, b);
      }
      if (maxDiff < 1) maxDiff = 1;
      let scale = sFactor / maxDiff;
      for (let i = 0; i < oArr.length; i += 4) {
        let r = Math.abs(oArr[i] - cArr[i]) * scale;
        let g = Math.abs(oArr[i + 1] - cArr[i + 1]) * scale;
        let b = Math.abs(oArr[i + 2] - cArr[i + 2]) * scale;
        dArr[i] = clamp(r, 0, 255);
        dArr[i+1] = clamp(g, 0, 255);
        dArr[i+2] = clamp(b, 0, 255);
        dArr[i+3] = 255;
      }
      dCtx.putImageData(diffData, 0, 0);
      return dCanvas;
    }

    function stitchImage(orig, diff, direction) {
      let w = orig.width, h = orig.height;
      let finalCanvas = document.createElement('canvas');
      let fCtx = finalCanvas.getContext('2d');

      switch(direction) {
          case 'left':
              finalCanvas.width = w * 2;
              finalCanvas.height = h;
              fCtx.drawImage(diff, 0, 0);
              fCtx.drawImage(orig, w, 0);
              break;
          case 'right':
              finalCanvas.width = w * 2;
              finalCanvas.height = h;
              fCtx.drawImage(orig, 0, 0);
              fCtx.drawImage(diff, w, 0);
              break;
          case 'top':
              finalCanvas.width = w;
              finalCanvas.height = h * 2;
              fCtx.drawImage(diff, 0, 0);
              fCtx.drawImage(orig, 0, h);
              break;
          case 'bottom':
              finalCanvas.width = w;
              finalCanvas.height = h * 2;
              fCtx.drawImage(orig, 0, 0);
              fCtx.drawImage(diff, 0, h);
              break;
      }
      return finalCanvas;
    }

    function drawResult(canvasElem, m = null, x = null, showDetails = null, originalImageX = 0, originalImageY = 0) {
      if (canvasElem) {
        resultCanvas.width = canvasElem.width;
        resultCanvas.height = canvasElem.height;
        rCtx.clearRect(0, 0, resultCanvas.width, resultCanvas.height);
        rCtx.drawImage(canvasElem, 0, 0);
      }

      if (showDetails && m !== null && x !== null) {
        const text = `m=${m}, x=${x}`;
        const padding = 10;
        
        rCtx.font = `8px 'Courier New', Courier, monospace`;
        rCtx.fillStyle = 'white';
        rCtx.lineWidth = 2;
        rCtx.strokeStyle = 'black';
        
        const textX = originalImageX + padding;
        const textY = originalImageY + loadedFile.height - padding;
        
        rCtx.strokeText(text, textX, textY);
        rCtx.fillText(text, textX, textY);
      }
    }

    function clamp(val, mn, mx) {
      return val < mn ? mn : val > mx ? mx : val;
    }

    function clampInt(val, mn, mx) {
      let v = Math.floor(Math.abs(val));
      return v < mn ? mn : v > mx ? mx : v;
    }
  </script>
</body>
</html>
